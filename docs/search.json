[{"path":"index.html","id":"acerca-del-sitio","chapter":"1 Acerca del sitio","heading":"1 Acerca del sitio","text":"En este repositorio voy compilar una serie de notebooks con ejemplos comparativos de codigo R y Python para implementar distintos métodos estadísticos. Estos notebooks asumen que el usuario conoce los fundamientos de ambos lenguajes.","code":""},{"path":"index.html","id":"motivación","chapter":"1 Acerca del sitio","heading":"1.1 Motivación","text":"Vengo usando R desde hace tiempo para análisis de datos en proyectos de investigación y consultoría, así como para la enseñanza de cursos de grado y posgrado en estadística aplicada.Siempre quise aprender Python pero nunca tuve la necesidad de cambiar de lenguaje. Es por que eso que este proyecto tiene como objetio personal ser un área de prueba para aprender Python replicando análisis que habitualmente corro usando R.","code":""},{"path":"index.html","id":"contenidos","chapter":"1 Acerca del sitio","heading":"1.2 Contenidos","text":"Estadísticas de resumen de una muestra pequeñaEstadística de resumenGráficos descriptivosHypothesis tests one 2 samplesRegresiónAnovaMultivariate","code":""},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"calentando-motores-estadístcas-de-resumen","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2 Calentando motores: estadístcas de resumen","text":"En esta parte vamos trabajar con un set de datos pequeño correspondiente estimaciones de rendimiento de soja (en tn/ha) de 25 lotes soja de una región. Los datos son:","code":"4.12, 4.61, 4, 5.46, 4.7, 4.01, 4.79, 4.94, 4.85, 4.32, 5.41, 4.73, 4.13, 3.17, 5.17, 4.47, 4.49, 5.07, 4.99, 4.86, 5.05, 4.97, 4.54, 3.31, 4.87"},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"leer-los-datos","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.1 Leer los datos","text":"El siguiente código muestra como cargar los datos de la muestra en un objeto llamado yields.","code":""},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"r","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.1.1 R","text":"La manera más simple de crearlo es usando la función c().","code":"\nyields <- c(\n  4.12, 4.61, 4, 5.46, 4.7, 4.01, 4.79, 4.94, 4.85, 4.32, 5.41,\n  4.73, 4.13, 3.17, 5.17, 4.47, 4.49, 5.07, 4.99, 4.86, 5.05,\n  4.97, 4.54, 3.31, 4.87\n)\nyields [1] 4.12 4.61 4.00 5.46 4.70 4.01 4.79 4.94 4.85 4.32 5.41\n[12] 4.73 4.13 3.17 5.17 4.47 4.49 5.07 4.99 4.86 5.05 4.97\n[23] 4.54 3.31 4.87"},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"python","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.1.2 Python","text":"Crearemos un objeto tipo list usando [ ]. Tambien podemos crear un tuple que es simiar pero mutable.","code":"yields = [\n  4.12, 4.61, 4, 5.46, 4.7, 4.01, 4.79, 4.94, 4.85, 4.32, 5.41,\n  4.73, 4.13, 3.17, 5.17, 4.47, 4.49, 5.07, 4.99, 4.86, 5.05,\n  4.97, 4.54, 3.31, 4.87\n]\nyields[4.12, 4.61, 4, 5.46, 4.7, 4.01, 4.79, 4.94, 4.85, 4.32, 5.41, 4.73, 4.13, 3.17, 5.17, 4.47, 4.49, 5.07, 4.99, 4.86, 5.05, 4.97, 4.54, 3.31, 4.87]"},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"the-sample-mean","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.2 The sample mean","text":"Para averiguar el rendimiento promedio de la muestra tenemos que aplicar la siguiente función:\\[\n\\bar{y} = \\dfrac{\\sum y_i}{n}\n\\]continuación vamos calcularlo mano, paso por paso, y creando una función. Finalmente lo haremos usando las funciones incluidas en ambos lenguajes.","code":""},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"r-1","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.2.1 R","text":"Calculando manoEncapsulando todo en una función:Lo mismo obtenemos usando la función mean()","code":"\n# Total de observaciones\ntot <- sum(yields)\n\n# Numero de elementos en la muestra\nn <- length(yields)\n\n# Promedio\nybar <- tot/n\nybar[1] 4.6012\n# Definir la función `media`\nmedia <- function(y) {\n  tot <- sum(y)\n  n <- length(y)\n  tot/n\n}\n\n# Aplicar función\nmedia(yields)[1] 4.6012\nmean(yields)[1] 4.6012"},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"python-1","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.2.2 Python","text":"Calculando manoEncapsulando todo en una función:Al contrario de R que ya incluye funciones estadísticas al inicio (paquete stats), en Python necesitamos importar modulos con import. Hay varias opciones: statistics, numpy y scipy. La más completa es el duo numpy/scipy que tiene funciones agrupadas en varios submodulos","code":"# Total de observaciones\ntot = sum(yields)\n\n# Numero de elementos en la muestra\nn = len(yields)\n\n# Promedio\nybar = tot/n\nybar4.6012# Definir la función `media`\ndef media(y):\n  tot = sum(y)\n  n = len(y)\n  return(tot/n)\n  \n\n# Aplicar función\nmedia(yields)4.6012# Importar libreria numpy\nimport numpy as np\n\n# Calcular media\nnp.mean(yields)4.6012"},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"standard-deviation","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.3 Standard deviation","text":"El desvió estándar de una muestra se define como:\\[\ns = \\sqrt{\\dfrac{\\sum (y_i - \\bar{y})^2}{n-1}}\n\\]continuación se muestra como calcularlo mano y usando funciones incluidas en ambos lenguajes. Aunque el calculo mano se puede hacer en un solo paso, voy mostrarlo por partes y creando una función.","code":""},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"r-2","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.3.1 R","text":"Calculando mano. Algunos datos ya los tenemos de antes ybar y nPoniendo todo en una funcionUsando la función sd()","code":"\n# Total de desvios al cuadrado\ntot_sq <- sum((yields - ybar)^2)\n\n# Desvio\ns <- sqrt(tot_sq/(n-1))\ns[1] 0.5698707\n# Definir funcion `desvio`\ndesvio <- function(y) {\n  n <- length(y)\n  ybar <- sum(y)/n\n  sum((y - ybar)^2)/(n-1)\n}\n\n# Aplicar función \ndesvio(x)[1] 0.3247527\nsd(yields)[1] 0.5698707"},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"python-2","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.3.2 Python","text":"Para calcular los desvios cuadráticos mano se requiere aplicar la función resta y potencia de elemento elemento. Por defecto las funciones están verctorizadas por lo que tenemos que iterar sobre los elementos de yield. Una opción es usando /loop o list-comprehension.El código anterior aplica la función (y - ybar)**2 cada elemento y contenido en yield y devuelve una nueva lista. Luego esa lista es usada para calcular el total.Como el cálculo del desvio requiere sacar la raiz cuadrada de la varianza, necesitamos importar la función sqrt() del módulo mathCreando una función:Usando la función std del paquete numpy que ya importamos antes.","code":"sq = [(y - ybar)**2 for y in yields]\ntot_sq = sum(sq)# Importar sqrt\nfrom math import sqrt\n\ns = sqrt(tot_sq/(n-1))\ns0.5698707455789134# Definiendo al funcion `desvio`\ndef desvio(y):\n  from math import sqrt\n  \n  n = len(y)\n  ybar = sum(y)/n\n  sq = [(y - ybar)**2 for y in yields]\n  tot_sq = sum(sq)\n  \n  return(sqrt(tot_sq/(n-1)))\n  \n\n# Aplicando la funcion\ndesvio(yields)0.5698707455789134np.std(yields)0.5583570184031001"},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"calculando-varias-estadísticas-a-la-vez","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.4 Calculando varias estadísticas a la vez","text":"Supongamos que queremos averiguar las siguientes estadísitcas descriptivas partir de los datos de la muestra y presentar los resultados en una tabla: media, desvio, varianza, minimo, máximo, cuartiles, asimetría y kurtosis.","code":""},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"r-3","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.4.1 R","text":"La manera más simple es creando un vector que contenga los resultados. Algunas funciones necesarias se encuentran en el paquete moments.Otra alternativa es poner los resultados en data.frameFinalmente, usando dplyr podemos aplicar facilmente una lista de funciones un conjunto de datos. Esto es extensible un conjunto de datos con grupos.","code":"\nresults <- c(\n  mean = mean(yields),\n  sd = sd(yields),\n  var = var(yields),\n  min = min(yields),\n  Q1 = quantile(yields, p = 0.25),\n  median =median(yields),\n  Q3 = quantile(yields, p = 0.75),\n  max = max(yields),\n  skw = moments::skewness(yields),\n  kurt = moments::kurtosis(yields)\n)\nresults      mean         sd        var        min     Q1.25% \n 4.6012000  0.5698707  0.3247527  3.1700000  4.3200000 \n    median     Q3.75%        max        skw       kurt \n 4.7300000  4.9700000  5.4600000 -0.9192805  3.5280435 \ndata.frame(t(results))    mean        sd       var  min Q1.25. median Q3.75.  max\n1 4.6012 0.5698707 0.3247527 3.17   4.32   4.73   4.97 5.46\n         skw     kurt\n1 -0.9192805 3.528043\nlibrary(dplyr)\n\nfuns <- list(\n  mean = ~ mean(.x),\n  sd = ~ sd(.x),\n  var = ~ var(.x),\n  min = ~ min(.x),\n  Q1 = ~ quantile(.x, p = 0.25),\n  median = ~median(.x),\n  Q3 = ~ quantile(.x, p = 0.75),\n  max = ~ max(.x),\n  skw = ~ moments::skewness(.x),\n  kurt = ~ moments::kurtosis(.x)\n) \n\nresults <- data.frame(yields) %>% \n  summarise(\n    across(.cols = everything(), .fns = funs, .names = \"{.fn}\")\n  )\nresults    mean        sd       var  min   Q1 median   Q3  max\n1 4.6012 0.5698707 0.3247527 3.17 4.32   4.73 4.97 5.46\n         skw     kurt\n1 -0.9192805 3.528043"},{"path":"calentando-motores-estadístcas-de-resumen.html","id":"python-3","chapter":"2 Calentando motores: estadístcas de resumen","heading":"2.4.2 Python","text":"La mayoria de las funciones de la lista se incluyen en el módulo numpy pero otras deben ser cargadas desde scipy.Primero calculamos las estadísticas y las guardamos en un objetio dict.Luego, el diccionaro se convierte en una estructura tipo DataFrame usando el módulo pandas.","code":"from scipy import stats as sp\n\nresults = {\n  \"mean\": np.mean(yields),\n  \"sd\": np.std(yields),\n  \"var\": np.var(yields),\n  \"min\": min(yields),\n  \"Q1\": np.quantile(yields, 0.25),\n  \"median\": np.median(yields),\n  \"Q3\": np.quantile(yields, 0.75),\n  \"max\": max(yields),\n  \"skw\": sp.stats.skew(yields),\n  \"kurt\": sp.stats.kurtosis(yields)\n}\nresults{'mean': 4.6012, 'sd': 0.5583570184031001, 'var': 0.31176255999999997, 'min': 3.17, 'Q1': 4.32, 'median': 4.73, 'Q3': 4.97, 'max': 5.46, 'skw': -0.9192805310042922, 'kurt': 0.5280434853525069}import pandas as pd\n\nresults = pd.DataFrame(results, index = [0])\nresults"}]
